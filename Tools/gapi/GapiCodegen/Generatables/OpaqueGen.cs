// GtkSharp.Generation.OpaqueGen.cs - The Opaque Generatable.
//
// Author: Mike Kestner <mkestner@speakeasy.net>
//
// Copyright (c) 2001-2003 Mike Kestner
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the GNU General Public
// License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.

using System.Xml;
using GapiCodegen.Utils;

namespace GapiCodegen.Generatables
{
    /// <summary>
    /// Handles 'boxed' and 'struct' elements with the "opaque" flag (by creating C# classes).
    /// </summary>
    public class OpaqueGen : HandleBase
    {
        public OpaqueGen(XmlElement namespaceElement, XmlElement element) : base(namespaceElement, element) { }

        public override string FromNative(string varName, bool owned)
        {
            return string.Format("{0} == IntPtr.Zero ? null : ({1}) GLib.Opaque.GetOpaque ({0}, typeof ({1}), {2})",
                varName, QualifiedName, owned ? "true" : "false");
        }

        private bool DisableRawCtor => Element.GetAttributeAsBoolean(Constants.DisableRawCtor);

        public override void Generate(GenerationInfo generationInfo)
        {
            generationInfo.CurrentType = QualifiedName;

            var streamWriter = generationInfo.Writer = generationInfo.OpenStream(Name, Namespace);

            streamWriter.WriteLine($"namespace {Namespace} {{");
            streamWriter.WriteLine();
            streamWriter.WriteLine("\tusing System;");
            streamWriter.WriteLine("\tusing System.Collections;");
            streamWriter.WriteLine("\tusing System.Collections.Generic;");
            streamWriter.WriteLine("\tusing System.Runtime.InteropServices;");
            streamWriter.WriteLine();

            streamWriter.WriteLine("#region Autogenerated code");

            var table = SymbolTable.Table;

            GetSpecialMethods(out var refMethod, out var unrefMethod, out var disposeMethod, out var setGValueMethod);

            if (IsDeprecated)
                streamWriter.WriteLine("\t[Obsolete]");

            streamWriter.Write("\t{0} partial {1}class {2}", IsInternal ? "internal" : "public",
                IsAbstract ? "abstract " : string.Empty, Name);

            var csParent = table.GetCsType(Element.GetAttribute(Constants.Parent));

            streamWriter.Write(!string.IsNullOrEmpty(csParent) ? $" : {csParent}" : " : GLib.Opaque");

            foreach (var @interface in ManagedInterfaces)
            {
                if (Parent != null && Parent.Implements(@interface))
                    continue;

                streamWriter.Write($", {@interface}");
            }

            streamWriter.WriteLine(" {");
            streamWriter.WriteLine();

            GenerateConstants(generationInfo);
            GenerateFields(generationInfo);
            GenerateMethods(generationInfo, null, null);
            GenerateConstructors(generationInfo);

            if (refMethod != null)
            {
                refMethod.GenerateImport(streamWriter);
                streamWriter.WriteLine("\t\tprotected override void Ref (IntPtr raw)");
                streamWriter.WriteLine("\t\t{");
                streamWriter.WriteLine("\t\t\tif (!Owned) {");
                streamWriter.WriteLine($"\t\t\t\t{refMethod.CName} (raw);");
                streamWriter.WriteLine("\t\t\t\tOwned = true;");
                streamWriter.WriteLine("\t\t\t}");
                streamWriter.WriteLine("\t\t}");
                streamWriter.WriteLine();

                if (refMethod.IsDeprecated)
                {
                    streamWriter.WriteLine($"\t\t[Obsolete(\"{QualifiedName} is now refcounted automatically\")]");

                    streamWriter.WriteLine(refMethod.ReturnType == "void"
                        ? "\t\tpublic void Ref () {}"
                        : $"\t\tpublic {Name} Ref () {{ return this; }}");

                    streamWriter.WriteLine();
                }
            }

            var finalizerNeeded = false;

            if (unrefMethod != null)
            {
                unrefMethod.GenerateImport(streamWriter);
                streamWriter.WriteLine("\t\tprotected override void Unref (IntPtr raw)");
                streamWriter.WriteLine("\t\t{");
                streamWriter.WriteLine("\t\t\tif (Owned) {");
                streamWriter.WriteLine($"\t\t\t\t{unrefMethod.CName} (raw);");
                streamWriter.WriteLine("\t\t\t\tOwned = false;");
                streamWriter.WriteLine("\t\t\t}");
                streamWriter.WriteLine("\t\t}");
                streamWriter.WriteLine();

                if (unrefMethod.IsDeprecated)
                {
                    streamWriter.WriteLine($"\t\t[Obsolete(\"{QualifiedName} is now refcounted automatically\")]");
                    streamWriter.WriteLine("\t\tpublic void Unref () {}");
                    streamWriter.WriteLine();
                }

                finalizerNeeded = true;
            }

            if (disposeMethod != null)
            {
                disposeMethod.GenerateImport(streamWriter);
                streamWriter.WriteLine("\t\tprotected override void Free (IntPtr raw)");
                streamWriter.WriteLine("\t\t{");
                streamWriter.WriteLine($"\t\t\t{disposeMethod.CName} (raw);");
                streamWriter.WriteLine("\t\t}");
                streamWriter.WriteLine();

                if (disposeMethod.IsDeprecated)
                {
                    streamWriter.WriteLine($"\t\t[Obsolete(\"{QualifiedName} is now freed automatically\")]");
                    streamWriter.WriteLine($"\t\tpublic void {disposeMethod.Name} () {{}}");
                    streamWriter.WriteLine();
                }

                finalizerNeeded = true;
            }

            if (finalizerNeeded)
            {
                streamWriter.WriteLine("\t\tclass FinalizerInfo {");
                streamWriter.WriteLine("\t\t\tIntPtr handle;");
                streamWriter.WriteLine();
                streamWriter.WriteLine("\t\t\tpublic FinalizerInfo (IntPtr handle)");
                streamWriter.WriteLine("\t\t\t{");
                streamWriter.WriteLine("\t\t\t\tthis.handle = handle;");
                streamWriter.WriteLine("\t\t\t}");
                streamWriter.WriteLine();
                streamWriter.WriteLine("\t\t\tpublic bool Handler ()");
                streamWriter.WriteLine("\t\t\t{");

                streamWriter.WriteLine("\t\t\t\t{0} (handle);",
                    disposeMethod != null ? disposeMethod.CName : unrefMethod.CName);

                streamWriter.WriteLine("\t\t\t\treturn false;");
                streamWriter.WriteLine("\t\t\t}");
                streamWriter.WriteLine("\t\t}");
                streamWriter.WriteLine();
                streamWriter.WriteLine("\t\t~{0} ()", Name);
                streamWriter.WriteLine("\t\t{");
                streamWriter.WriteLine("\t\t\tif (!Owned)");
                streamWriter.WriteLine("\t\t\t\treturn;");
                streamWriter.WriteLine("\t\t\tFinalizerInfo info = new FinalizerInfo (Handle);");
                streamWriter.WriteLine("\t\t\tGLib.Timeout.Add (50, new GLib.TimeoutHandler (info.Handler));");
                streamWriter.WriteLine("\t\t}");
                streamWriter.WriteLine();
            }

#if false
			Method copy = Methods ["Copy"] as Method;
			if (copy != null && copy.Parameters.Count == 0) {
				sw.WriteLine ("\t\tprotected override GLib.Opaque Copy (IntPtr raw)");
				sw.WriteLine ("\t\t{");
				sw.WriteLine ("\t\t\tGLib.Opaque result = new " + QualifiedName + " (" + copy.CName + " (raw));");
				sw.WriteLine ("\t\t\tresult.Owned = true;");
				sw.WriteLine ("\t\t\treturn result;");
				sw.WriteLine ("\t\t}");
				sw.WriteLine ();
			}
#endif

            if (setGValueMethod != null)
            {
                streamWriter.WriteLine("\t\tdelegate IntPtr d_{0}(ref GLib.Value val, IntPtr obj);", setGValueMethod.CName);
                streamWriter.WriteLine("\t\tstatic d_{0} {0} = FuncLoader.LoadFunction<d_{0}>(FuncLoader.GetProcAddress(GLibrary.Load({1}), \"{0}\"));", setGValueMethod.CName, LibraryName);
                streamWriter.WriteLine();
                streamWriter.WriteLine("\t\tpublic void SetGValue (ref GLib.Value val)");
                streamWriter.WriteLine("\t\t{");
                streamWriter.WriteLine("\t\t\t{0} (ref val, Handle);", setGValueMethod.CName);
                streamWriter.WriteLine("\t\t}");
                streamWriter.WriteLine();
            }

            GenerateStructAbi(generationInfo);
            streamWriter.WriteLine("#endregion");

            streamWriter.WriteLine("\t}");
            streamWriter.WriteLine("}");
            streamWriter.Close();

            generationInfo.Writer = null;
            Statistics.OpaqueCount++;
        }

        protected override void GenerateConstructors(GenerationInfo generationInfo)
        {
            if (!DisableRawCtor)
            {
                generationInfo.Writer.WriteLine($"\t\tpublic {Name}(IntPtr raw) : base(raw) {{}}");
                generationInfo.Writer.WriteLine();
            }

            base.GenerateConstructors(generationInfo);
        }

        private void GetSpecialMethods(out Method refMethod, out Method unrefMethod, out Method disposeMethod,
            out Method setGValueMethod)
        {
            refMethod = CheckSpecialMethod(GetMethod("Ref"));
            unrefMethod = CheckSpecialMethod(GetMethod("Unref"));

            disposeMethod = GetMethod("Free") ?? GetMethod("Destroy") ?? GetMethod("Dispose");

            disposeMethod = CheckSpecialMethod(disposeMethod);

            setGValueMethod = GetMethod("SetGValue");
            Methods.Remove("SetGValue");
        }

        private Method CheckSpecialMethod(Method method)
        {
            if (method == null)
                return null;

            if (method.ReturnType != "void" &&
                method.ReturnType != QualifiedName)
                return null;

            if (method.Signature.ToString() != "")
                return null;

            Methods.Remove(method.Name);
            return method;
        }
    }
}
